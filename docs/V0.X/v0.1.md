#V0.1
>基于JDK原生NIO API构建一个能简单的读写通信的cs程序，服务端只支持一个连接

#目录
* [遇到的问题列表](#problem-lists) 
	* [服务端](#server)
	* [客户端](#client)
	* [公共](#all)

##Problem lists  
:kissing_heart: `已阅读Netty源码验证` 或 `不需验证`  
:heart_eyes: `已解决未验证`  
:sob: `未解决`   
####Server  
1. :kissing_heart: `如何判断客户端close了？` 如果客户端关闭了或者进程意外退出了，服务端会收到OP_READ事件，但是Read的时候会抛出IOException，基于IOException，可以断定客户端close了，同时关闭服务端对应的Channel  
*  :sob: `客户端断了的时候，为何服务端会触发两次OP_READ事件？` 第一次调用`SocketChannel#read`没有数据但是不报错，第二次调用会报错？  

####Client  
1. :sob: `如何判断服务端连接成功了？``SocketChannel#connect`并不会立即连接成功，需要注册OP_CONNECT事件，然后select到connect事件的时候，说明连接成功 `未验证`  
* `注册了OP_CONNECT事件后，客户端会频繁收到connect事件，怎么处理？`需要在收到OP_CONNECT事件的时候，通过`SelectionKey#interestOps(SelectionKey#interestOps() & ~SelectionKey.OP_CONNECT)` 把key上注册的connect事件反注册掉 `未验证`  
* :heart_eyes: `客户端通过监听OP_CONNECT事件发现连上服务端之后，写数据到服务端会抛出NotYetConnectedException` 客户端需要在OP_CONNECT事件触发后，调用`SocketChannel#finishConnect`方法，来完成连接，如果此时方法返回为false，则说明连接出问题了 `未验证`  
* :sob: `服务端强行kill掉进程后，客户端会一直监听到OP_READ事件，但是读不到数据，如何处理？`
* `xxx`
	
####All  
1. :kissing_heart: `ByteBuffer使用注意事项` 从channel读数据到ByteBuffer以后，一定要flip，然后再调用`ByteBuffer#remaining、ByteBuffer#get`等方法
